//! Proof-of-concept: Accessing service metadata from the ServiceRegistry
//!
//! This binary demonstrates that we can query all the metadata needed
//! for Swift codegen from the rapace ServiceRegistry.

use facet_core::{Def, ScalarType, Shape, Type, UserType};
use rapace::prelude::*;
use rapace::registry::ServiceRegistry;

// ============================================================================
// Define a sample service (similar to browser-tests-proto)
// ============================================================================

/// Request payload describing a list of integers.
#[derive(Clone, Debug, facet::Facet)]
pub struct NumbersRequest {
    pub values: Vec<i32>,
}

/// Statistical summary returned by `summarize_numbers`.
#[derive(Clone, Debug, facet::Facet)]
pub struct NumbersSummary {
    pub sum: i64,
    pub mean: f64,
    pub min: i32,
    pub max: i32,
}

/// Request payload for transforming a phrase.
#[derive(Clone, Debug, facet::Facet)]
pub struct PhraseRequest {
    pub phrase: String,
    pub shout: bool,
}

/// Response payload for the phrase transformation.
#[derive(Clone, Debug, facet::Facet)]
pub struct PhraseResponse {
    pub title: String,
    pub original_len: u32,
}

/// Streaming item produced by the countdown RPC.
#[derive(Clone, Debug, facet::Facet)]
pub struct CountEvent {
    pub value: u32,
    pub remaining: u32,
}

/// A person with optional address
#[derive(Clone, Debug, facet::Facet)]
pub struct Person {
    pub name: String,
    pub age: u32,
    pub email: Option<String>,
    pub tags: Vec<String>,
}

/// Example enum for testing enum introspection
#[derive(Clone, Debug, facet::Facet)]
#[repr(u8)]
pub enum Status {
    Pending,
    Active,
    Completed { result: String },
    Failed { error: String, code: i32 },
}

/// Service exercised by the browser tests.
#[allow(async_fn_in_trait)]
#[rapace::service]
pub trait BrowserDemo {
    /// Compute aggregate statistics over an arbitrary sequence of integers.
    async fn summarize_numbers(&self, input: NumbersRequest) -> NumbersSummary;

    /// Transform a phrase and optionally "shout" it.
    async fn transform_phrase(&self, request: PhraseRequest) -> PhraseResponse;

    /// Stream a countdown starting from `start` down to zero.
    async fn countdown(&self, start: u32) -> Streaming<CountEvent>;

    /// Get a person by name.
    async fn get_person(&self, name: String) -> Option<Person>;

    /// Get current status.
    async fn get_status(&self) -> Status;
}

// ============================================================================
// Main: Populate registry and print all metadata
// ============================================================================

fn main() {
    println!("=== Rapace Service Registry Codegen POC ===\n");

    // Populate the global registry by calling the register function
    // (generated by the #[rapace::service] macro)
    ServiceRegistry::with_global_mut(|registry| {
        browser_demo_register(registry);
    });

    // Now query the registry and print all metadata
    ServiceRegistry::with_global(|registry| {
        println!("Total services: {}", registry.service_count());
        println!("Total methods: {}\n", registry.method_count());

        for service in registry.services() {
            print_service(service);
        }
    });
}

fn print_service(service: &rapace::registry::ServiceEntry) {
    println!("================================================================================");
    println!("SERVICE: {}", service.name);
    println!("--------------------------------------------------------------------------------");
    println!("  ID: {}", service.id.0);
    if !service.doc.is_empty() {
        println!("  Doc: {}", service.doc);
    }
    println!("  Methods: {}", service.methods.len());
    println!();

    for method in service.iter_methods() {
        print_method(method);
    }
}

fn print_method(method: &rapace::registry::MethodEntry) {
    println!("  METHOD: {}", method.name);
    println!("  --------");
    println!("    Full name: {}", method.full_name);
    println!("    Method ID: {} (0x{:08X})", method.id.0, method.id.0);
    println!("    Streaming: {}", method.is_streaming);
    if !method.doc.is_empty() {
        println!("    Doc: {}", method.doc);
    }

    // Print arguments
    println!("    Arguments:");
    if method.args.is_empty() {
        println!("      (none)");
    } else {
        for arg in &method.args {
            println!("      - {}: {}", arg.name, arg.type_name);
        }
    }

    // Print request type shape
    println!("    Request Shape:");
    print_shape(method.request_shape, 6);

    // Print response type shape
    println!("    Response Shape:");
    print_shape(method.response_shape, 6);

    println!();
}

fn print_shape(shape: &'static Shape, indent: usize) {
    let pad = " ".repeat(indent);

    println!("{}Type identifier: {}", pad, shape.type_identifier);

    // Check for scalar types first
    if let Some(scalar) = shape.scalar_type() {
        let affinity = scalar_affinity(scalar);
        println!("{}Kind: Scalar ({})", pad, affinity);
        return;
    }

    // Check container types via Def
    match &shape.def {
        Def::Option(option_def) => {
            println!("{}Kind: Option", pad);
            println!("{}Inner type:", pad);
            print_shape(option_def.t(), indent + 2);
            return;
        }
        Def::List(list_def) => {
            println!("{}Kind: List/Vec", pad);
            println!("{}Item type:", pad);
            print_shape(list_def.t(), indent + 2);
            return;
        }
        Def::Map(map_def) => {
            println!("{}Kind: Map", pad);
            println!("{}Key type:", pad);
            print_shape(map_def.k(), indent + 2);
            println!("{}Value type:", pad);
            print_shape(map_def.v(), indent + 2);
            return;
        }
        Def::Array(array_def) => {
            println!("{}Kind: Array [{}]", pad, array_def.n);
            println!("{}Item type:", pad);
            print_shape(array_def.t(), indent + 2);
            return;
        }
        Def::Result(result_def) => {
            println!("{}Kind: Result", pad);
            println!("{}Ok type:", pad);
            print_shape(result_def.t(), indent + 2);
            println!("{}Err type:", pad);
            print_shape(result_def.e(), indent + 2);
            return;
        }
        _ => {}
    }

    // Check user types (structs, enums)
    match &shape.ty {
        Type::User(UserType::Struct(struct_type)) => {
            println!("{}Kind: Struct ({:?})", pad, struct_type.kind);
            println!("{}Fields:", pad);
            for field in struct_type.fields.iter() {
                println!("{}  - {} (offset: {:?}):", pad, field.name, field.offset);
                print_shape(field.shape(), indent + 4);
            }
        }
        Type::User(UserType::Enum(enum_type)) => {
            println!("{}Kind: Enum ({:?})", pad, enum_type.enum_repr);
            println!("{}Variants:", pad);
            for variant in enum_type.variants.iter() {
                println!(
                    "{}  - {} (discriminant: {:?}):",
                    pad, variant.name, variant.discriminant
                );
                if !variant.data.fields.is_empty() {
                    for field in variant.data.fields.iter() {
                        println!("{}      field {}: ", pad, field.name);
                        print_shape(field.shape(), indent + 8);
                    }
                }
            }
        }
        Type::User(UserType::Union(union_type)) => {
            println!("{}Kind: Union", pad);
            println!("{}Fields:", pad);
            for field in union_type.fields.iter() {
                println!("{}  - {}:", pad, field.name);
                print_shape(field.shape(), indent + 4);
            }
        }
        Type::User(UserType::Opaque) => {
            println!("{}Kind: Opaque", pad);
        }
        Type::Sequence(seq_type) => {
            println!("{}Kind: Sequence ({:?})", pad, seq_type);
        }
        Type::Pointer(ptr_type) => {
            println!("{}Kind: Pointer ({:?})", pad, ptr_type);
        }
        Type::Primitive(prim_type) => {
            println!("{}Kind: Primitive ({:?})", pad, prim_type);
        }
        Type::Undefined => {
            println!("{}Kind: Undefined", pad);
        }
    }
}

fn scalar_affinity(scalar: ScalarType) -> &'static str {
    match scalar {
        ScalarType::String | ScalarType::Str | ScalarType::CowStr => "string",
        ScalarType::Bool => "boolean",
        ScalarType::Char => "char",
        ScalarType::F32 | ScalarType::F64 => "float",
        ScalarType::I8
        | ScalarType::I16
        | ScalarType::I32
        | ScalarType::I64
        | ScalarType::I128
        | ScalarType::ISize => "signed integer",
        ScalarType::U8
        | ScalarType::U16
        | ScalarType::U32
        | ScalarType::U64
        | ScalarType::U128
        | ScalarType::USize => "unsigned integer",
        _ => "unknown",
    }
}
